---
phase: 19-chain-preference-logic
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/server/src/db/index.ts
  - packages/server/src/db/user-preferences.ts
  - packages/server/src/routes/admin.ts
  - apps/dashboard/src/lib/api.ts
  - apps/dashboard/src/lib/chain-preference-defaults.ts
autonomous: true

must_haves:
  truths:
    - "User's chain preference is persisted to database"
    - "API returns user's preference or calculated default"
    - "API accepts preference updates (PUT request)"
    - "Default preference is calculated from payment history and wallet balances"
  artifacts:
    - path: "packages/server/src/db/user-preferences.ts"
      provides: "User preference storage functions"
      exports: ["getUserPreference", "upsertUserPreference", "UserPreference"]
    - path: "apps/dashboard/src/lib/chain-preference-defaults.ts"
      provides: "Default preference calculation logic"
      exports: ["getDefaultChainPreference"]
  key_links:
    - from: "packages/server/src/routes/admin.ts"
      to: "packages/server/src/db/user-preferences.ts"
      via: "getUserPreference, upsertUserPreference calls"
      pattern: "(getUserPreference|upsertUserPreference)"
    - from: "packages/server/src/routes/admin.ts"
      to: "subscriptions table"
      via: "payment history query for default calculation"
      pattern: "getSubscriptionsByUserId"
---

<objective>
Add backend infrastructure for storing and retrieving user chain preferences with intelligent default calculation.

Purpose: Enable users to set their preferred payment chain (Base or Solana) with server-side persistence for cross-device sync and payment engine access.

Output: Database table, CRUD functions, API endpoints, default preference logic, and API client methods.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/19-chain-preference-logic/19-CONTEXT.md
@.planning/phases/19-chain-preference-logic/19-RESEARCH.md
@.planning/phases/18-multi-chain-wallet-infrastructure/18-01-SUMMARY.md

Key context from CONTEXT.md:
- Preference persists to database (cross-device sync)
- Default: most recent payment chain > highest balance wallet > Solana
- Preference change takes effect immediately
- No confirmation dialog needed

API Design from RESEARCH.md:
- GET /api/admin/preference -> { preferredChain: 'base' | 'solana' }
- PUT /api/admin/preference -> { preferredChain: 'base' | 'solana', updated: boolean }
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create user preferences database layer</name>
  <files>
    packages/server/src/db/user-preferences.ts
    packages/server/src/db/index.ts
  </files>
  <action>
Create new file `packages/server/src/db/user-preferences.ts` with:

1. Interface `UserPreference`:
   - id: string
   - user_id: string
   - preferred_chain: 'base' | 'solana'
   - created_at: string
   - updated_at: string

2. Functions:
   - `getUserPreference(userId: string): UserPreference | null`
   - `upsertUserPreference(userId: string, preferredChain: 'base' | 'solana'): UserPreference`

In `packages/server/src/db/index.ts`:

1. Add CREATE TABLE for user_preferences:
```sql
CREATE TABLE IF NOT EXISTS user_preferences (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL UNIQUE REFERENCES "user" ("id") ON DELETE CASCADE,
  preferred_chain TEXT NOT NULL DEFAULT 'solana' CHECK (preferred_chain IN ('base', 'solana')),
  created_at TEXT NOT NULL DEFAULT (datetime('now')),
  updated_at TEXT NOT NULL DEFAULT (datetime('now'))
);
CREATE INDEX IF NOT EXISTS idx_user_preferences_user ON user_preferences(user_id);
```

2. Add export: `export * from './user-preferences.js';`

Use the existing pattern from user-wallets.ts for reference (randomUUID for id, getDatabase() calls).
  </action>
  <verify>
Run `npx tsc --noEmit -p packages/server/tsconfig.json` - no type errors.
Check that user-preferences.ts exports getUserPreference and upsertUserPreference.
  </verify>
  <done>
user_preferences table exists in schema, getUserPreference and upsertUserPreference functions exported.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create default preference calculation logic</name>
  <files>
    apps/dashboard/src/lib/chain-preference-defaults.ts
  </files>
  <action>
Create new file with pure function for determining default preference.

```typescript
import type { SubscriptionPayment, SubscriptionWallet } from './api';

/**
 * Determines the default chain preference based on:
 * 1. Most recent payment chain (if any payments exist)
 * 2. Highest balance wallet (if no payments)
 * 3. Solana (if both wallets empty)
 */
export function getDefaultChainPreference(
  payments: SubscriptionPayment[],
  wallets: SubscriptionWallet[]
): 'base' | 'solana' {
  // Priority 1: Most recent payment chain
  if (payments.length > 0) {
    const sorted = [...payments].sort(
      (a, b) => new Date(b.date).getTime() - new Date(a.date).getTime()
    );
    const mostRecentChain = sorted[0].chain.toLowerCase();
    if (mostRecentChain === 'base' || mostRecentChain === 'solana') {
      return mostRecentChain;
    }
  }

  // Priority 2: Highest balance wallet
  const baseWallet = wallets.find(w => w.network === 'base');
  const solanaWallet = wallets.find(w => w.network === 'solana');

  const baseBalance = baseWallet ? parseFloat(baseWallet.balance) : 0;
  const solanaBalance = solanaWallet ? parseFloat(solanaWallet.balance) : 0;

  if (baseBalance > solanaBalance) return 'base';
  if (solanaBalance > baseBalance) return 'solana';

  // Priority 3: Default to Solana
  return 'solana';
}
```

This is a pure function - no side effects, easily testable, used by both frontend (for optimistic default) and can inform backend if needed.
  </action>
  <verify>
Run `npx tsc --noEmit -p apps/dashboard/tsconfig.json` - no type errors.
Verify function is exported from the file.
  </verify>
  <done>
getDefaultChainPreference function exists, handles all three priority levels, returns 'base' | 'solana'.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add preference API endpoints and client methods</name>
  <files>
    packages/server/src/routes/admin.ts
    apps/dashboard/src/lib/api.ts
  </files>
  <action>
In `packages/server/src/routes/admin.ts`:

1. Import at top:
```typescript
import { getUserPreference, upsertUserPreference } from '../db/user-preferences.js';
import { getSubscriptionsByUserId } from '../db/subscriptions.js';
import { getAllWalletsForUser, getUSDCBalance, getBaseUSDCBalance } from '../services/wallet.js';
```

2. Add GET endpoint (after other wallet endpoints, around line 380):
```typescript
// GET /api/admin/preference - Get user's chain preference
router.get('/preference', requireAuth, async (req: Request, res: Response) => {
  try {
    const userId = req.user!.id;

    // Check for existing preference
    const preference = getUserPreference(userId);

    if (preference) {
      return res.json({ preferredChain: preference.preferred_chain });
    }

    // Calculate default if no preference set
    // Get payment history
    const subscriptions = getSubscriptionsByUserId(userId);
    const payments = subscriptions.map(s => ({
      chain: 'solana', // Legacy payments were Solana-only
      date: s.created_at,
    }));

    // Get wallet balances
    const wallets = await getAllWalletsForUser(userId);
    const walletsWithBalances = await Promise.all(
      wallets.map(async (w) => {
        const balance = w.network === 'solana'
          ? await getUSDCBalance(w.wallet_address)
          : await getBaseUSDCBalance(w.wallet_address);
        return {
          network: w.network as 'base' | 'solana',
          address: w.wallet_address,
          balance: balance.formatted,
          token: 'USDC',
        };
      })
    );

    // Determine default
    let defaultChain: 'base' | 'solana' = 'solana';

    // Check payments first
    if (payments.length > 0) {
      const sorted = [...payments].sort(
        (a, b) => new Date(b.date).getTime() - new Date(a.date).getTime()
      );
      const mostRecent = sorted[0].chain.toLowerCase();
      if (mostRecent === 'base' || mostRecent === 'solana') {
        defaultChain = mostRecent;
      }
    } else {
      // Check balances
      const baseWallet = walletsWithBalances.find(w => w.network === 'base');
      const solanaWallet = walletsWithBalances.find(w => w.network === 'solana');
      const baseBalance = baseWallet ? parseFloat(baseWallet.balance) : 0;
      const solanaBalance = solanaWallet ? parseFloat(solanaWallet.balance) : 0;

      if (baseBalance > solanaBalance) defaultChain = 'base';
    }

    return res.json({ preferredChain: defaultChain });
  } catch (error) {
    console.error('Error getting preference:', error);
    return res.status(500).json({ error: 'Failed to get preference' });
  }
});
```

3. Add PUT endpoint:
```typescript
// PUT /api/admin/preference - Update user's chain preference
router.put('/preference', requireAuth, async (req: Request, res: Response) => {
  try {
    const userId = req.user!.id;
    const { preferredChain } = req.body;

    if (!preferredChain || !['base', 'solana'].includes(preferredChain)) {
      return res.status(400).json({ error: 'Invalid preferredChain. Must be "base" or "solana".' });
    }

    const preference = upsertUserPreference(userId, preferredChain);

    return res.json({
      preferredChain: preference.preferred_chain,
      updated: true,
    });
  } catch (error) {
    console.error('Error updating preference:', error);
    return res.status(500).json({ error: 'Failed to update preference' });
  }
});
```

In `apps/dashboard/src/lib/api.ts`:

1. Add types (after SubscriptionWallet types, around line 230):
```typescript
export interface ChainPreference {
  preferredChain: 'base' | 'solana';
}

export interface ChainPreferenceUpdateResponse {
  preferredChain: 'base' | 'solana';
  updated: boolean;
}
```

2. Add methods to ApiClient class (after subscription methods, around line 920):
```typescript
// Chain Preference
async getChainPreference(): Promise<ChainPreference> {
  return this.request('/api/admin/preference');
}

async updateChainPreference(chain: 'base' | 'solana'): Promise<ChainPreferenceUpdateResponse> {
  return this.request('/api/admin/preference', {
    method: 'PUT',
    body: JSON.stringify({ preferredChain: chain }),
  });
}
```
  </action>
  <verify>
Run `npx tsc --noEmit -p packages/server/tsconfig.json` - no type errors.
Run `npx tsc --noEmit -p apps/dashboard/tsconfig.json` - no type errors.
Start server and test:
- `curl -X GET http://localhost:5002/api/admin/preference` (with auth cookie) returns preferredChain
- `curl -X PUT http://localhost:5002/api/admin/preference -d '{"preferredChain":"base"}' -H 'Content-Type: application/json'` (with auth cookie) returns updated preference
  </verify>
  <done>
GET /api/admin/preference returns current or default preference.
PUT /api/admin/preference persists preference change.
API client has getChainPreference() and updateChainPreference() methods.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors in both packages
2. Server starts successfully
3. GET /api/admin/preference returns valid response
4. PUT /api/admin/preference persists and returns updated preference
5. Default calculation logic follows priority order (payment > balance > solana)
</verification>

<success_criteria>
- PREF-01 (partial): Default calculation logic implemented
- Backend ready for PREF-02 (toggle) and PREF-03 (fallback in Phase 20)
- Database persistence working
- API endpoints functional
- API client methods available for frontend use
</success_criteria>

<output>
After completion, create `.planning/phases/19-chain-preference-logic/19-01-SUMMARY.md`
</output>
