---
phase: 03-solana-address-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/dashboard/package.json
  - apps/dashboard/src/components/providers/solana-provider.tsx
  - apps/dashboard/src/components/providers.tsx
  - packages/server/src/utils/solana-verify.ts
  - packages/server/src/routes/rewards.ts
autonomous: true

must_haves:
  truths:
    - "Solana wallet adapter providers are available in dashboard"
    - "Server can verify Ed25519 signatures from Solana wallets"
    - "Enroll endpoint rejects requests without valid signatures"
  artifacts:
    - path: "apps/dashboard/src/components/providers/solana-provider.tsx"
      provides: "Wallet adapter context providers"
      exports: ["SolanaProvider"]
    - path: "packages/server/src/utils/solana-verify.ts"
      provides: "Server-side signature verification"
      exports: ["verifySolanaSignature", "createVerificationMessage"]
  key_links:
    - from: "apps/dashboard/src/components/providers.tsx"
      to: "solana-provider.tsx"
      via: "import and wrap"
      pattern: "SolanaProvider"
    - from: "packages/server/src/routes/rewards.ts"
      to: "solana-verify.ts"
      via: "import verifySolanaSignature"
      pattern: "verifySolanaSignature"
---

<objective>
Set up Solana wallet adapter infrastructure in dashboard and add signature verification to the enrollment API endpoint.

Purpose: Enable wallet connection and message signing in frontend; secure enrollment by requiring cryptographic proof of address ownership.

Output: SolanaProvider component wrapping app, server-side signature verification utility, updated /api/rewards/enroll endpoint requiring signature.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-solana-address-management/03-CONTEXT.md
@.planning/phases/03-solana-address-management/03-RESEARCH.md
@.planning/phases/02-auth-integration/02-01-SUMMARY.md

# Existing files to understand patterns
@packages/server/src/routes/rewards.ts
@apps/dashboard/src/components/providers.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Solana wallet adapter and create SolanaProvider</name>
  <files>
    apps/dashboard/package.json
    apps/dashboard/src/components/providers/solana-provider.tsx
    apps/dashboard/src/components/providers.tsx
  </files>
  <action>
1. Install wallet adapter packages in dashboard:
   ```bash
   cd apps/dashboard && pnpm add @solana/wallet-adapter-react @solana/wallet-adapter-react-ui @solana/wallet-adapter-wallets @solana/wallet-adapter-base
   ```

2. Create `apps/dashboard/src/components/providers/solana-provider.tsx`:
   - 'use client' directive (SSR safety)
   - Import ConnectionProvider, WalletProvider from @solana/wallet-adapter-react
   - Import WalletModalProvider from @solana/wallet-adapter-react-ui
   - Import WalletAdapterNetwork from @solana/wallet-adapter-base
   - Import clusterApiUrl from @solana/web3.js
   - Import wallet adapter CSS: `import "@solana/wallet-adapter-react-ui/styles.css"`
   - Use Mainnet network, get endpoint via clusterApiUrl(network)
   - Pass empty wallets array (auto-detect standard wallets)
   - Set autoConnect={false} (user triggers connection)
   - Export SolanaProvider component that wraps children with all three providers

3. Update `apps/dashboard/src/components/providers.tsx`:
   - Import SolanaProvider from './providers/solana-provider'
   - Wrap children with SolanaProvider (inside ThemeProvider, outside AuthProvider)
   - Order: QueryClientProvider > ThemeProvider > SolanaProvider > AuthProvider
  </action>
  <verify>
    - `pnpm build` in apps/dashboard succeeds without errors
    - No SSR/hydration errors when running `pnpm dev`
  </verify>
  <done>
    - Wallet adapter packages installed
    - SolanaProvider component exists and exports correctly
    - App wrapped with wallet adapter providers
  </done>
</task>

<task type="auto">
  <name>Task 2: Create server-side signature verification utility</name>
  <files>
    packages/server/src/utils/solana-verify.ts
  </files>
  <action>
1. Create `packages/server/src/utils/solana-verify.ts`:

2. Import dependencies:
   - `import { ed25519 } from '@noble/curves/ed25519'`
   - `import bs58 from 'bs58'`
   - `import { PublicKey } from '@solana/web3.js'`

3. Export `createVerificationMessage(address: string): string`:
   ```typescript
   return `OpenFacilitator Rewards

Sign to verify ownership of:
${address}

This will not cost any SOL.`;
   ```
   Note: Use exact format with double newlines. This message format must match what frontend sends.

4. Export `verifySolanaSignature(address: string, signature: string, message: string): boolean`:
   - Wrap in try/catch, return false on any error
   - Validate address is valid Solana address: `new PublicKey(address)`
   - Decode signature from base58: `bs58.decode(signature)`
   - Encode message to bytes: `new TextEncoder().encode(message)`
   - Verify using ed25519: `ed25519.verify(signatureBytes, messageBytes, publicKey.toBytes())`
   - Return verification result (boolean)

5. Add JSDoc comments explaining:
   - Message format must match client-side exactly
   - Signature is base58-encoded (wallet adapter standard)
   - Uses Ed25519 curve (Solana signing algorithm)
  </action>
  <verify>
    - TypeScript compiles: `cd packages/server && pnpm build`
    - Functions exported from utils/solana-verify.ts
  </verify>
  <done>
    - `createVerificationMessage` function exported
    - `verifySolanaSignature` function exported
    - Both functions have proper types and error handling
  </done>
</task>

<task type="auto">
  <name>Task 3: Update enroll endpoint to require signature verification</name>
  <files>
    packages/server/src/routes/rewards.ts
  </files>
  <action>
1. Import verification utilities at top:
   `import { verifySolanaSignature, createVerificationMessage } from '../utils/solana-verify.js'`

2. Update enrollSchema to require signature:
   ```typescript
   const enrollSchema = z.object({
     chain_type: z.enum(['solana', 'evm']),
     address: z.string().min(1, 'Address is required'),
     signature: z.string().min(1, 'Signature is required'),
     message: z.string().min(1, 'Message is required'),
   });
   ```

3. Update POST /enroll handler BEFORE createRewardAddress call:

   a. After validation, check chain_type === 'solana' (only chain supported this phase):
      - If not solana, return 400: `{ error: 'Validation error', message: 'Only Solana addresses supported currently' }`

   b. Verify expected message matches what client signed:
      ```typescript
      const expectedMessage = createVerificationMessage(address);
      if (message !== expectedMessage) {
        return res.status(400).json({
          error: 'Validation error',
          message: 'Message format mismatch',
        });
      }
      ```

   c. Verify signature:
      ```typescript
      if (!verifySolanaSignature(address, signature, message)) {
        return res.status(400).json({
          error: 'Validation error',
          message: 'Invalid signature - could not verify address ownership',
        });
      }
      ```

   d. Check global uniqueness BEFORE insert (per CONTEXT.md - one address per user globally):
      ```typescript
      import { getRewardAddressByAddress } from '../db/reward-addresses.js';

      const existingAddress = getRewardAddressByAddress(address, chain_type);
      if (existingAddress) {
        return res.status(409).json({
          error: 'Conflict',
          message: 'This address is already registered',
        });
      }
      ```

   e. Check address limit per user (5 addresses max per RESEARCH.md recommendation):
      ```typescript
      const userAddresses = getRewardAddressesByUser(userId);
      if (userAddresses.length >= 5) {
        return res.status(400).json({
          error: 'Limit reached',
          message: "You've reached the maximum number of addresses (5)",
        });
      }
      ```

4. After createRewardAddress succeeds, immediately mark as verified (atomic flow per CONTEXT.md):
   ```typescript
   import { verifyRewardAddress } from '../db/reward-addresses.js';

   // After createRewardAddress...
   if (created) {
     verifyRewardAddress(created.id);
     // Re-fetch to get updated verification status
     const verified = getRewardAddressById(created.id);
     res.status(201).json(verified);
   }
   ```

5. Update import to include getRewardAddressById if not already imported.
  </action>
  <verify>
    - TypeScript compiles: `cd packages/server && pnpm build`
    - Start server: `cd packages/server && pnpm dev`
    - Test missing signature returns 400:
      `curl -X POST http://localhost:5002/api/rewards/enroll -H "Content-Type: application/json" -d '{"chain_type":"solana","address":"test"}' -c cookies.txt` (after auth)
  </verify>
  <done>
    - Enroll endpoint requires signature, message fields
    - Invalid signatures rejected with 400
    - Global address uniqueness enforced (409 on duplicate)
    - 5 address limit per user enforced
    - Successful enrollment immediately marks address as verified
  </done>
</task>

</tasks>

<verification>
1. Dashboard builds without errors: `cd apps/dashboard && pnpm build`
2. Server builds without errors: `cd packages/server && pnpm build`
3. Dashboard starts without SSR errors: `cd apps/dashboard && pnpm dev`
4. Wallet adapter providers available (check React DevTools for context)
5. Enroll endpoint rejects requests without valid signature
</verification>

<success_criteria>
- Solana wallet adapter infrastructure ready for use by enrollment UI
- Server-side signature verification prevents unauthorized address registration
- Atomic verify-on-create flow implemented per CONTEXT.md
- Address limits and global uniqueness enforced
</success_criteria>

<output>
After completion, create `.planning/phases/03-solana-address-management/03-01-SUMMARY.md`
</output>
